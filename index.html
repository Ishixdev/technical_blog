<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
  </head>
  <body>
    <h1>The Winner Of NASA’S trust: Node.js!</h1><hr>
    <div class="maindiv">
      <div class="block">
        <p>
          One of the most crucial booms in the tech industry after transistors
          is undoubtedly Node.js. The most complex and creative UI designs are
          just skeletal structures without it. At first, front-end development
          seemed limited to HTML and CSS. But with today’s trends, JavaScript
          takes centre stage! And with Node.js in the picture, is there anything
          better?
        </p>
      </div>
      <h2 class="headers">
        <ul>
          <li>What is Node.js?</li>
        </ul>
      </h2>
      <div class="block">
        <p>
          To understand this, let's consider the situation of tech platforms
          before the ground-breaking invention of Node.js. When front-end was
          all about HTML, CSS, and JavaScript, users and developers realised
          that JavaScript, in its true form, was made to be used in a browser.
          This meant that it was completely impossible to use it in anything
          that did not pertain to a website per se. Thus, JavaScript was used
          for functionality and logical domain of an application, which points
          to the fact that it wasn’t accessible for other crucial functions and
          that there were a lot of restrictions. All of this changed with the
          introduction of the hero of our story, Node.js! Let us shed a little
          light on what Node.js does. According to the developers of Node.js, it
          is roughly defined as follows:
        </p>
      </div>
      <div class="quotediv">
        <span class="quote">
          “An asynchronous, event–driven JavaScript runtime environment.”
        </span>
      </div>
      <div class="block">
        <p>
          Hence we learn that Node.js is a runtime environment built on the V8
          engine. Built with C and C++, it is extremely fast. That is why it
          powers Chrome. This gave developers two great control factors:
        </p>
        <ol>
          <li>
            Now, JavaScript was accessible outside the working arena of a
            browser with all the necessary tools required for its execution
            (runtime environment).
          </li>
          <li>
            It can now be used to develop cross–platform desktop applications
            and also control the server side of the client-server model.
          </li>
        </ol>
      </div>
      <div class="block">
        <p>
          However, a common question is, why would someone want to use an
          additional framework (though Node.js isn’t a framework either, as we
          will see in the following sections) when the existing JavaScript is
          efficient on its own? Let us understand that.
        </p>
      </div>
      <h2>
        <ul>
          <li>Why do we need a framework?</li>
        </ul>
      </h2>
      <div class="block">
        <p>
          A framework essentially has components and structures that are
          prebuilt. Now, the task is much easier because we do not need to write
          every single bit of the code.
        </p>
      </div>
      <div>
        <p>
          To explain the same, a lecturer quoted, “Why would you make Mayo from
          scratch if you can directly buy it, considering that it is used
          frequently?”
        </p>
      </div><div class="block">
      <h2>
        <ul>
          <li>Why node.js?</li>
        </ul>
      </h2>
      </div>
      <div class="block">
        <p>The reasons for using Node.js are listed as follows:</p>
        <ul>
          <li>
            <h3 class="sec_header">Speed:</h3>
            <p>
              The efficiency and agility with which tasks are executed, thanks
              to the Architecture model used, is one of the prime reasons for
              web applications with a smooth interface, processing, loading, and
              application.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Scalability:</h3>
            <p>
              A feature of Node.js that stands out is its ability to handle
              growth. Because of the smoothness in task handling as discussed
              previously, a lot of the architecture isn’t rewritten whenever
              there are improvements or advancements that need to be included in
              a particular application. This makes Node.js scalable.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Asynchronous:</h3>
            <p>
              To understand this, let us first understand what Synchronous is.
              Imagine a scenario where there is a chef in a multi-cuisine
              restaurant. When multiple customers come in order to access the
              services (food), the chef prepares one dish at a time, blocking
              the resources and the rest of the tasks. Thus, the customers keep
              waiting until the dish for the current customer is prepared. This
              is exactly what happens in a Synchronous format. When the tasks to
              be performed are given, each task in the list takes a turn to be
              executed, holding the resources until the task is executed.
            </p>
            <p>
              An Asynchronous format, on the other hand, has the tasks running
              independently. This tells us that it does not wait for the
              completion of one task before starting another. Productive
              multitasking at its finest!
            </p>
          </li>
          <li>
            <h3 class="sec_header">Huge Ecosystem:</h3>
            <p>
              The NPM packages are evidence of the huge ecosystem that uses and
              contributes to Node.js frequently. Some modules can be used to
              generate random names and random superhero names. All these
              packages are contributed by developers and users all around the
              world, and it is a certainty that if there is a problem you are
              stuck on, some developer on Stack Overflow would have a solution
              to it!
            </p>
          </li>
          <li>
            <h3 class="sec_header">Non–blocking:</h3>
            <p>
              As the resources are not held by a single task being executed,
              thanks to the asynchronous property of Node.js, these resources
              are not blocked, and neither are the tasks. Therefore, the program
              manages many tasks at once, making it super fast!
            </p>
          </li>
          <li>
            <h3 class="sec_header">Event-driven:</h3>
            <p>
              Unlike the usual flow of JavaScript, node.js flows with respect to
              events. Only when an event is to be executed, the resources are
              used. This ensures that all other properties of Node.js stand true
              and the execution is seamless and smooth. This feature also makes
              it an ideal platform to use for high-traffic applications!
            </p>
          </li>
          <li>
            <h3 class="sec_header">Single-Threaded Event Loop:</h3>
            <p>
              Let us come back to our restaurant analogy. Now the head chef
              decided that since he is not able to manage the customers by
              himself, he will appoint a chef for every customer that comes.
              Eventually, it got harder and harder for him to manage and
              allocate salaries for each chef. This is what basic JavaScript
              does. For every task, a new thread is allotted. This leads to
              extra memory and resource usage. That is why Node.js uses Single
              single-threaded event loop. This is essentially a single
              intelligent chef who prepares the next dish as the previous ones
              are being cooked, thus managing the resources without loading the
              memory.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Server model:</h3>
            <p>
              All the processing is done at the server end, thus delays due to
              loading of data and carrying out processes do not occur on the
              client end, making it much more efficient.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Single Page Applications (SPA):</h3>
            <p>
              Imagine a website such that, for every button clicked, the whole
              website reloads. Sounds tedious and time-consuming, does it not? A
              Single Page Application undoes that. To state precisely, Node.js
              stays active until the app is closed. This ensures that all
              processes are executed quickly!
            </p>
          </li>
          <li>
            <h3 class="sec_header">
              Increase in the number of Full Stack Developers:
            </h3>
            <p>
              As Node.js is a JavaScript-based runtime environment, a lot of
              front-end developers weren’t required to learn a new language in
              order to understand back-end; they could do that just by using
              Node.
            </p>
          </li>
        </ul>
      </div>
      <div class="block">
        <p>
          All these advantages make Node.js a perfect framework to use for all
          kinds of development. We can find that companies use Node.js for
          different reasons. These companies include Netflix, PayPal, eBay, and
          LinkedIn. Here is the Easter egg from the title:
        </p>
      </div>
      <div class="block">
        <p>
          According to an article posted in 2020, NASA utilizes Node.js in
          various applications, the biggest use case of which is data management
          and retrieval. This was adopted after the data got scattered, and due
          to the lack of efficient data management, one of their astronauts
          nearly lost their lives. So, if NASA can trust Node.js, we definitely
          can!
        </p>
        <ul>
          <li>
            Use Cases of Node.js:
            <ul>
              <li>Real-time applications</li>
              <li>Data Streaming</li>
              <li>IoT</li>
              <li>Web Applications</li>
              <li>Back-end</li>
            </ul>
          </li>
        </ul>
        <p>
          Well, there is one more crucial Use Case we are missing here, <br />
          <strong>The Front End!</strong>
        </p>
      </div>
      <div class="block">
        Node.js is generally used as a back-end technology. This helps any
        front-end developer to perform full-stack development because the entire
        application can be coded using JavaScript. However, one cannot assume
        that it can’t be used for front-end development.Let us understand how
        Node.js helps in front-end development:
      </div>
      <div class="img_div">
        <img src="flowchart.png" alt="Image of a flowchart." />
        <p>Fig: Flow Chart for the flow of front-end.</p>
      </div>
      <div class="block">
        <p>
          Consider Node.js to be a factory producing cars. It powers the
          following:
        </p>
        <ul>
          <li>React.js</li>
          <li>SCSS</li>
          <li>TypeScript</li>
          <li>Babel</li>
          <li>Vite</li>
          <li>Webpack</li>
        </ul>
      </div>
      <div class="block">
        <p>
          Let us understand the functions of each of those, referencing the
          factory analogy.
        </p>
        <ol>
          <li>
            <h3 class="sec_header">React.js:</h3>
            <p>
              It is our blueprint generator. It is used to create the structure,
              UI design, and behaviour of the front end. It uses JSX, which is a
              better version of JavaScript.
            </p>
          </li>
          <li>
            <h3 class="sec_header">SCSS:</h3>
            <p>
              Our car cannot run on a skeletal structure. How about we give it
              some colour, texture, and finish? This is the department of our
              SCSS. It stands for SASS CSS. It is used to create CSS files with
              variables to style every bit of the HTML pages. The usage of
              variables helps with efficient formatting and repetition wherever
              required.
            </p>
          </li>
          <li>
            <h3 class="sec_header">TypeScript:</h3>
            <p>
              It is our quality controller inspector. Considering our analogy,
              it is used to create certain rules and structure to ensure the
              best possible output. At the end, it converts the hybrid forms to
              JavaScript to their simplest forms, keeping some JSX intact.
            </p>
          </li>
          <li>
            <h3 class="sec_header">SASS Compiler:</h3>
            <p>
              Consider that the browser is the road. The browser does not
              understand the blueprint or the variable-oriented style sheets.
              Therefore, just stating that the car is of a certain colour is
              gibberish to the road. Thus, we need to give it a standard paint
              set. In our tech system, the browser only understands basic CSS.
              So, the SASS compiler (Syntactically Awesome Style Sheets
              Compiler) is used to convert the SCSS files to normal CSS. The
              browser can easily understand and execute these sheets.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Babel:</h3>
            <p>
              Our car is finally coming together! If I need to run the car, I
              need to have someone explain its language, something that can be
              the mediator between the browser and the files, right? Remember
              how TypeScript converted the files and still retained some JSX
              files? These are files that have the latest versions of JavaScript
              with extra additions and are advanced. Our road, and in this
              scenario, our browser, cannot understand such JavaScript. This is
              why Babel comes to our rescue! It converts these advanced
              JavaScript files to their basic version, making them compatible
              with all kinds of browsers.
            </p>
          </li>
          <li>
            <h3 class="sec_header">Webpack:</h3>
            <p>
              Congratulations! All parts of our very own personalised car are
              ready! Wait a minute, how can we take these parts home? We need it
              in the form of a car, after all. Someone needs to put everything
              together. This is done by the Webpack, a tool that is better known
              as a Module Bundler. It creates “Bundles” or optimized files. Now
              I don’t need to take separate parts of the car, I have a whole car
              I can use altogether! This finally runs on the browser, thus
              completing our application development.
            </p>
          </li>
          <li>
            <h3 class="sec_header">7.Vite:</h3>
            <p>
              An alternative to Webpack is Vite. This is also an assembler, with
              just one key difference – it presumes that the browser being used
              is up to date. Thus, it understands the latest JavaScript
              versions. This ensures that the conversion doesn’t take time, and
              that it is fast and efficient!
            </p>
          </li>
        </ol>
      </div>
      <div class="block">
        <p>
          Here it is – our very own web application brought to completion,
          crafted with finesse, in our very own digital factory powered by
          Node.js! 
        </p>
      </div>
      <div class="block">
        <p>Thus, we understand that Node.js is a powerful tool that not
          only serves as a beautiful framework for front-end development but
          also plays a key role in back-end development. And as the trends can
          be seen, having Node.js under your belt is never going to let you
          down. As the trends on GitHub suggest, the need for Node will always
          soar high!</p>
      </div>
    </div>
  </body>
</html>
